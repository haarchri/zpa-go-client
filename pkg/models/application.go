// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Application application
//
// swagger:model Application
type Application struct {

	// bypass type
	// Enum: [ALWAYS NEVER ON_NET]
	BypassType string `json:"bypassType,omitempty"`

	// config space
	// Enum: [DEFAULT SIEM]
	ConfigSpace string `json:"configSpace,omitempty"`

	// creation time
	CreationTime int32 `json:"creationTime,omitempty"`

	// default idle timeout
	DefaultIdleTimeout int32 `json:"defaultIdleTimeout,omitempty"`

	// default max age
	DefaultMaxAge int32 `json:"defaultMaxAge,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// domain name
	DomainName string `json:"domainName,omitempty"`

	// domain names
	DomainNames []string `json:"domainNames"`

	// double encrypt
	DoubleEncrypt bool `json:"doubleEncrypt,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// health check type
	// Enum: [DEFAULT NONE]
	HealthCheckType string `json:"healthCheckType,omitempty"`

	// icmp access type
	// Enum: [PING_TRACEROUTING PING NONE]
	IcmpAccessType string `json:"icmpAccessType,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// ip anchored
	IPAnchored bool `json:"ipAnchored,omitempty"`

	// log features
	LogFeatures []string `json:"logFeatures"`

	// modified by
	ModifiedBy int64 `json:"modifiedBy,omitempty"`

	// modified time
	ModifiedTime int32 `json:"modifiedTime,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// passive health enabled
	PassiveHealthEnabled bool `json:"passiveHealthEnabled,omitempty"`

	// server groups
	ServerGroups []*AppServerGroup `json:"serverGroups"`

	// tcp port ranges
	TCPPortRanges []string `json:"tcpPortRanges"`

	// tcp ports in
	TCPPortsIn []string `json:"tcpPortsIn"`

	// tcp ports out
	TCPPortsOut []string `json:"tcpPortsOut"`

	// udp port ranges
	UDPPortRanges []string `json:"udpPortRanges"`
}

// Validate validates this application
func (m *Application) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBypassType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHealthCheckType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIcmpAccessType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServerGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var applicationTypeBypassTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ALWAYS","NEVER","ON_NET"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationTypeBypassTypePropEnum = append(applicationTypeBypassTypePropEnum, v)
	}
}

const (

	// ApplicationBypassTypeALWAYS captures enum value "ALWAYS"
	ApplicationBypassTypeALWAYS string = "ALWAYS"

	// ApplicationBypassTypeNEVER captures enum value "NEVER"
	ApplicationBypassTypeNEVER string = "NEVER"

	// ApplicationBypassTypeONNET captures enum value "ON_NET"
	ApplicationBypassTypeONNET string = "ON_NET"
)

// prop value enum
func (m *Application) validateBypassTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationTypeBypassTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Application) validateBypassType(formats strfmt.Registry) error {
	if swag.IsZero(m.BypassType) { // not required
		return nil
	}

	// value enum
	if err := m.validateBypassTypeEnum("bypassType", "body", m.BypassType); err != nil {
		return err
	}

	return nil
}

var applicationTypeConfigSpacePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEFAULT","SIEM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationTypeConfigSpacePropEnum = append(applicationTypeConfigSpacePropEnum, v)
	}
}

const (

	// ApplicationConfigSpaceDEFAULT captures enum value "DEFAULT"
	ApplicationConfigSpaceDEFAULT string = "DEFAULT"

	// ApplicationConfigSpaceSIEM captures enum value "SIEM"
	ApplicationConfigSpaceSIEM string = "SIEM"
)

// prop value enum
func (m *Application) validateConfigSpaceEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationTypeConfigSpacePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Application) validateConfigSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigSpace) { // not required
		return nil
	}

	// value enum
	if err := m.validateConfigSpaceEnum("configSpace", "body", m.ConfigSpace); err != nil {
		return err
	}

	return nil
}

var applicationTypeHealthCheckTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEFAULT","NONE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationTypeHealthCheckTypePropEnum = append(applicationTypeHealthCheckTypePropEnum, v)
	}
}

const (

	// ApplicationHealthCheckTypeDEFAULT captures enum value "DEFAULT"
	ApplicationHealthCheckTypeDEFAULT string = "DEFAULT"

	// ApplicationHealthCheckTypeNONE captures enum value "NONE"
	ApplicationHealthCheckTypeNONE string = "NONE"
)

// prop value enum
func (m *Application) validateHealthCheckTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationTypeHealthCheckTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Application) validateHealthCheckType(formats strfmt.Registry) error {
	if swag.IsZero(m.HealthCheckType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHealthCheckTypeEnum("healthCheckType", "body", m.HealthCheckType); err != nil {
		return err
	}

	return nil
}

var applicationTypeIcmpAccessTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PING_TRACEROUTING","PING","NONE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationTypeIcmpAccessTypePropEnum = append(applicationTypeIcmpAccessTypePropEnum, v)
	}
}

const (

	// ApplicationIcmpAccessTypePINGTRACEROUTING captures enum value "PING_TRACEROUTING"
	ApplicationIcmpAccessTypePINGTRACEROUTING string = "PING_TRACEROUTING"

	// ApplicationIcmpAccessTypePING captures enum value "PING"
	ApplicationIcmpAccessTypePING string = "PING"

	// ApplicationIcmpAccessTypeNONE captures enum value "NONE"
	ApplicationIcmpAccessTypeNONE string = "NONE"
)

// prop value enum
func (m *Application) validateIcmpAccessTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationTypeIcmpAccessTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Application) validateIcmpAccessType(formats strfmt.Registry) error {
	if swag.IsZero(m.IcmpAccessType) { // not required
		return nil
	}

	// value enum
	if err := m.validateIcmpAccessTypeEnum("icmpAccessType", "body", m.IcmpAccessType); err != nil {
		return err
	}

	return nil
}

var applicationLogFeaturesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["skip_discovery","full_wildcard"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationLogFeaturesItemsEnum = append(applicationLogFeaturesItemsEnum, v)
	}
}

func (m *Application) validateLogFeaturesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationLogFeaturesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Application) validateLogFeatures(formats strfmt.Registry) error {
	if swag.IsZero(m.LogFeatures) { // not required
		return nil
	}

	for i := 0; i < len(m.LogFeatures); i++ {

		// value enum
		if err := m.validateLogFeaturesItemsEnum("logFeatures"+"."+strconv.Itoa(i), "body", m.LogFeatures[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *Application) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Application) validateServerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ServerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ServerGroups); i++ {
		if swag.IsZero(m.ServerGroups[i]) { // not required
			continue
		}

		if m.ServerGroups[i] != nil {
			if err := m.ServerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serverGroups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serverGroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this application based on the context it is used
func (m *Application) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateServerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Application) contextValidateServerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ServerGroups); i++ {

		if m.ServerGroups[i] != nil {
			if err := m.ServerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serverGroups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serverGroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Application) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Application) UnmarshalBinary(b []byte) error {
	var res Application
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
